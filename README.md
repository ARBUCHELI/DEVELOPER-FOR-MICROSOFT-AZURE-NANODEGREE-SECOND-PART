# CLOUD DEVELOPER USING MICROSOFT AZURE NANODEGREE

## This repository contains the lessons and quizzes from Cloud Developer Using Microsoft Azure Nanodegree Program.

## The first part corresponds to the material provided during the first phase of the scholarship.

# LESSON 1 INTRODUCTION TO MICROSOFT AZURE DEVELOPMENT:

## Prerequisites:

To succeed in this course, students should have experience in the following areas:

* Python (1-3 years of programming experience preferred), with experience building Flask apps
* SQL Server or MySQL to store and query data (you can get by with other SQL flavors as well)
* Using Git to pull and push code

## Lesson Outline:

This lesson will focus on the following topics under Microsoft Azure Cloud Development:

* Why cloud computing is important, when to use it, and who are the key stakeholders
* History of the cloud
* Microsoft Azure and Azure Portal
* Comparing cloud service types (such as Infrastructure as a Service, Platform as a Service, and Software as a Service)
* Tools and environment set up for the course
* The final course project

## Course Outline:

The course is divided into 3 major sections - Azure Compute Services, Storage Options in Azure, and Security, Monitoring and Logging.

![image](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/1.jpg)

## Introduction to Cloud Development:

The cloud is a collection of servers on the internet that store and manage data, run apps, and deliver content such as email or videos. Cloud computing is the delivery of software and storage over the Internet (i.e. the cloud).

Some of the benefits of using cloud computing are:

* Cost
* Scale
* Reliability
* Security

The three major types of cloud services are Public, Private, and Hybrid cloud. The major differences between these are in where they are deployed, and who manages them. Microsoft OneDrive, Microsoft Azure, and Microsoft Office365 are examples of public cloud options.

Cloud Developers perform some of the following:

* Plan and design cloud based apps
* Monitor, maintain and support cloud applications
* Develop work flows and processes

![image](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/2.jpg)

![image](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/3.jpg)

## Why Cloud Development Is Important

You've probably worked with various cloud services before, such as Microsoft OneDrive and Google Docs, and of course, you'll be working with Microsoft Azure in this course.

Some of the advantages of cloud computing are:

* Cost: The cloud provider handles all the upfront costs associated with buying hardware, along with on-going maintenance costs
* Scale: Most are pay-as-you-go depending on demand (elasticity), and can be expanded as needed
* Reliability: Management of backups, disaster recovery, etc. is made easier
* Security: Policies and controls are already in place to protect your data

Some of the disadvantages of cloud computing are:

* It is internet-based, so it can be prone to outages and fluctuations in speed
* Sensitive, private and core data is physically located on someone else's server
* Cloud services will be tailored and customized for your specific cloud instance, potentially making it hard to quickly change providers

![image](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/4.jpg)

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/5.jpg)

## Business Stakeholders

As a cloud developer, you will interact and engage with numerous stakeholders, each of whom has different priorities. Some of these are:

* Your users.
* Company executives.
* I.T. Department.
* Cloud Service provider.
* Finance Department.

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/6.jpg)

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/7.jpg)

## History of Cloud Development

The roots of cloud computing go as far back as the 1960s.

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/8.jpg)

1969 - JCR Licklider aimed to create a system where information could be accessed anywhere in the world called the “Intergalactic Computer Network”.

1980s - Supercomputing Centers start to form and Commercial Internet Service Providers start to emerge in the late 1980s.

1990 - The internet becomes visible to all when Tim Berners-Lee invents the World Wide Web.

1999 - Salesforce.com launches and becomes a pioneer in delivering enterprise applications over the internet, which is known as Software-as-a-Service(SaaS). This paves the way for other SaaS applications such as Microsoft 365 and Gmail.

2002 - Amazon launches its Amazon Web Services (AWS) platform. AWS is formally launched as a business unit in 2006.

2006 - Amazon launches its Elastic Compute Cloud (EC2), a commercial web service that allowed users to rent computers to run their applications. EC2 paved the way for application delivery over the internet, which allowed web-scaled businesses like Netflix and Spotify to exist.

2007 - Dropbox introduces its file hosting service, and with that cloud storage becomes a commodity.

2008 - Google launches its Google App Engine (GAE) Platform-as-a-Service (PaaS). This service allowed developers to host their web applications on Google’s managed data centers.

2010 - Microsoft launches its cloud computing platform, Azure, after announcing it back in 2008. Azure now covers Software-as-a-Service(SaaS), Platform-as-a-Service(PaaS), and Infrastructure-as-a-Service(IaaS).

2011 - IBM launches SmartCloud, a suite of enterprise-class cloud computing technologies for building private, public, and hybrid clouds.

2013 - Google launches Google Compute Engine (GCE) as an addition to its Google Compute Platform. This is an Infrastructure-as-a-Service (IaaS) component of the platform that allows a user to spin up Virtual Machines (VMs) on demand.

So what’s next? Cloud computing is on the rise in this day and age. As cloud computing continues to become more mainstream, more and more companies are looking to adopt it. Industries such as marketing, education, and healthcare are beginning to increase their use of cloud-based services and platforms.

## Microsoft Azure

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/9.jpg)

Azure is a public computing platform with tremendous value and benefits:

* Scalability: can dynamically handle changes in volume, bandwidth, storage size
* Availability: redundant on a global scale with 99.9%+ uptime (see SLA by service here)
* Security: replicated data helps protect against natural disaster, while authentication strategies help secure access to the data
* Standard delivery pipeline development services, such as:
  * Source control
  * Unit testing
  * Integration testing
  * Delivery
* Live development tools

Azure products span multiple categories, such as Compute, Analytics, Databases, A.I. and Machine Learning.

The Azure products this course will focus on are:

* App Services
* Virtual Machines
* Azure SQL Databases
* Blob Storage
* Azure Active Directory
* Aspects of Azure Monitor, such as logs and alerts

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/10.jpg)

## The Azure Portal

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/11.jpg)

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/12.jpg)

## IaaS, PaaS, and SaaS

In contrast to on-premises solutions, there are three types of services that Azure offers us:

* Infrastructure as a Service (IaaS) - removes the expense of up-front costs of hardware, software and test environments
* Platform as a Service (PaaS) - handles networking, provides middleware and development & database tools
* Software as a Service (SaaS) - provides end-users access to online cloud solutions

![](https://video.udacity-data.com/topher/2020/July/5f10a86a_azure-service-level-comparison/azure-service-level-comparison.png)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/13.jpg)

## Tools & Environment

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/14.jpg)

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/15.jpg)

## Project: Deploy an Article CMS to Azure

It is exciting to take a look at what we will be creating in our <strong>final course project</strong>. Similar to many such systems that exist in the real world, we will be designing, building, and deploying an Article Content Management System (CMS), which will include the ability to :

* Login and authenticate
* Read posts
* Create and save a post
* Edit and save an existing post

The project looks straightforward from the user interface, but there is a lot going on under the hood of this Flask app. The Sign In page makes use of the Microsoft Authentication Library (MSAL) and Azure Active Directory to log in with a Microsoft account, while data related to article titles, authors and text bodies is stored in an Azure SQL Server. An Azure Storage Account with Blob Storage is used to store the images, and the web app itself can be deployed using either an Azure Virtual Machine or an Azure App Service. All of these resources are likely tied to a single resource group.

All these terms may not make much sense to you yet, but by the end of the course, you'll know each resource involved quite well, and be able to deploy your own Article CMS with Azure!

![](https://video.udacity-data.com/topher/2020/March/5e6f8ed6_article-cms/article-cms.png)

## Lesson Recap

What did we learn in this introductory lesson on Azure Cloud Development?

* Why cloud computing is important, when to use it, and who are the key stakeholders
* History of the cloud
* Microsoft Azure and Azure Portal
* Comparing cloud service types - IaaS, PaaS and SaaS
* Tools and environment set up for the course
* The final course project

## Glosary

* <strong>The Cloud</strong>	A collection of servers on the internet that store and manage data, run apps, and deliver content such as email or videos.
* <strong>Cloud Computing</strong>	The delivery of software and storage over the Internet (i.e. the cloud).
* <strong>Public Cloud</strong>	Cloud computing resources shared amongst multiple customers, with applications and data still separate.
* <strong>Private Cloud</strong>	Cloud computing resources that are dedicated to only one entity. This is most similar to how on-premises resources operate, but with the resources still hosted off-site by a third party.
* <strong>Hybrid Cloud</strong>	Utilizing a mix of public and private cloud resources.
* <strong>Cloud Developer</strong>	Developers who build cloud applications or utilize other cloud resources in their applications. They are responsible for ensuring applications run efficiently in the cloud, requiring appropriate authentication to access, and identifying appropriate resources to use.
* <strong>Microsoft Azure</strong>	A public computing platform provided by Microsoft, with many products spanning many categories, such as Compute, Analytics, Databases, A.I. and Machine Learning.
* <strong>Azure Portal</strong>	The browser-based and GUI version of working with Azure resources.
* <strong>Elasticity</strong>	The ability to scale up or down resources to match demand.
* <strong>On-Premises</strong>	The non-cloud option where companies host all their necessary compute, storage and other resources on-site.
* <strong>Infrastructure as a Service (Iaas)</strong>	Removes the expense of up-front costs of hardware, software and test environments, as the cloud provider is instead responsible for providing physical hardware.
* <strong>Platform as a Service (Paas)</strong>	Handles networking, provides middleware and development & database tools, in addition to the physical hardware provided at the IaaS level.
* <strong>Software as a Service (Saas)</strong>	Provides end-users access to online cloud solutions, without the need to build or support the underlying applications themselves.

_________________________________________________________________________________________________________________________________________________________________________________

# LESSON 2 AZURE COMPUTE DEVICES

## Introduction

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/17.jpg)

In this lesson, we'll focus on Azure Compute Services:

* First, we'll take a look at some of the various compute options available
* Then, we'll get you set up for success by discussing subscriptions and resource groups
* From there, we'll take a deeper dive into two compute services in Azure: Virtual Machines and App Services
* After comparing and contrasting these two, you'll create both resources and deploy an app to them

![](https://video.udacity-data.com/topher/2020/July/5f10a6cb_course-outline-compute/course-outline-compute.png)

## Big Picture: Compute Services

There are a lot of compute services available through Azure, each with their own use cases. You can check out a good chart for deciding when to use each (which you'll see more of in later lessons and courses) in the Microsoft documentation. Some of the available options are:

* Virtual Machines
* App Services
* Azure Batch
* Azure Functions
* Container Instances
* Service Fabric
* Azure Kubernetes Service (AKS)

We'll focus on Virtual Machines and App Services in this lesson, although you'll see some of the others in a later course.

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/18.jpg)

## Subscriptions and Resource Groups

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/19.jpg)

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/20.jpg)

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/21.jpg)

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/22.jpg)

This starts at the top with your <strong>Azure Account</strong>. The next level down is the <strong>Subscription</strong> level; in this course you will likely only work with one subscription, but it's likely in your day-to-day Azure work that you may be working with more than one. For instance, there may be one subscription for development and testing, and another for production systems.

Below the subscription level is where you'll find <strong>Resource Groups</strong>. These help to organize resources you use, such as Virtual Machines and App Services (as well as storage options and other resources we'll discuss in later lessons), in order to make resource management easier. You may have a resource group for a specific project, or because resource groups are tied to a <strong>Region</strong>, you may have resource groups containing similar resources in multiple locations across the world. A region contains at least one data center, but could have multiple data centers that are close by and networked together through a low-latency network. There are over 60 regions available worldwide and available in 140 countries, such as East US and Japan West.

![](https://video.udacity-data.com/topher/2020/July/5f108911_subscription-resource-group-hierarchy/subscription-resource-group-hierarchy.png)

When choosing a region, it's important to consider what you are trying to achieve. For development and testing purposes, you likely want a region close to yourself; for production purposes, you often want resources to be close to your user. Keep the following in mind:

* Service availability - Some services may not be available in a particular region.
* Performance - Latency determines network service performance; are you creating resources for yourself or your end user?
* Cost - Costs of services vary by region. If latency isn’t an issue, you might want to deploy your services in the cheapest region.

### Creating a Resource Group in the Azure Portal

To set up a resource group in the Azure Portal:

* Go to the [Azure Portal homepage](http://portal.azure.com/)
* Click "Create a Resource Group"
* Search for "Resource group" and click "Create"
* You'll need to select the subscription for the resource group, name it, and select a region
* Make sure once you select "Review and create" to actually review the information! While it doesn't take too much time to go back and create a new resource group, you'll want to check for any typos in the name or if the wrong region was selected. When we work out of Azure CLI later, this becomes even more important, as you could cause other scripts to fail if things are named incorrectly or are in an inappropriate region.
* Click "Create" once you are done reviewing.

You'll practice this yourself in the upcoming exercise.

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/23.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/24.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/25.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/26.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/27.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/28.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/29.jpg)

Please open the link in a second tab to watch the tutorial:

[![IMAGE ALT TEXT](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/23.jpg)](https://www.youtube.com/watch?v=_9nHPP0gixc&feature=emb_logo)

## Exercise: Create A Resource Group

In this exercise, you'll create a resource group in Azure. This is a quick exercise, but will set you up for success through the rest of the course!

* Create a Resource Group named <strong>resource-group-west</strong> in Azure in the <strong>West US</strong> region.

<strong>Note:</strong> We will use this resource group throughout the course, so do not delete it after creation. Resource Groups are fully covered in the Azure free account.

## Solution (Alternative Solution using the CLI)

Please open the link in a second tab to watch the tutorial:

[![IMAGE ALT TEXT](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/38.jpg)](https://www.youtube.com/watch?v=rmWRvxY0Hh8&feature=emb_logo)

### Steps to Create a Resource Group using the Azure CLI:

* 1. Log in using az login.
* 2. We'll use the Azure CLI command az group create and pass in two flags:
   * resource group --name
   * --location which is the same as the "region" field on the Azure portal.
* 3. If you want to see a list of all locations, you can run az account list-locations -o table to output the list in table format.
* 4. I want to create my resource group in the West US 2 region:

az group create --name resource-group-west --location westus2

The resource group will be created and a JSON response will be returned with the status.

Alternatively, you can check out the screenshot below for how you might do the same from the Portal (note that the below uses the West US region and not West US 2).

![](https://video.udacity-data.com/topher/2020/July/5f075271_resource-group-solution/resource-group-solution.png)

Please open the link in a second tab to watch the tutorial:

[![IMAGE ALT TEXT](https://video.udacity-data.com/topher/2020/July/5f075271_resource-group-solution/resource-group-solution.png)](https://www.youtube.com/watch?v=rmWRvxY0Hh8&feature=emb_logo)

## Virtual Machines vs. App Services

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/30.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/31.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/32.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/33.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/34.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/35.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/36.jpg)

### Virtual Machines
<strong>Azure Virtual Machines</strong> (VMs) provide infrastructure as a service (IaaS) by allowing you to create and use virtual machines in the cloud.

Some of the benefits of VMs are:

* VMs allow you full access and control of the VM.
* Lower up-front cost compared to purchasing and maintaining hardware.
* Support of both Linux and Windows VMs.
* Multiple types to choose from, such as compute or memory-optimized VMs, along with varying amounts of CPU, RAM and storage.
* VMs allow for the installation of custom images and are an excellent choice for migrating from an on-premises server to the cloud.
* Multiple VMs can be grouped to provide high availability, scalability, and redundancy. There are two options when it comes to scaling—Virtual Machine Scale Sets and Load Balancers. These will be covered in a different course.

Some of the limitations of VMs are:

* They are more expensive
* They can be more time consuming for the developer than other compute options

### App Service
<strong>Azure App Service</strong> is an HTTP-based service for hosting web applications, REST APIs, and mobile back ends. It is a Platform as a Service (PaaS) that allows a developer to focus on the application while Azure takes care of the infrastructure.

Some of the benefits of using an App Service are:

* Support of multiple languages, such as .NET, .NET Core, Java, Ruby, Node.js, PHP, or Python
* High availability, auto-scaling and support of both Linux and Windows environments.
* Continuous deployment model using GitHub, Azure DevOps, or any Git repo.
* Vertical or Horizontal scaling. Vertical scaling increases or decreases resources allocated to our App Service, such as the amount of vCPUs or RAM, by changing the App Service pricing tier. Horizontal scaling increases or decreases the number of Virtual Machine instances our App Service is running.
* You can set the amount of hardware allocated to host your application, and cost varies based on the plan you choose. There are three different tiers - Dev/Test, Production, and Isolated. We’ll be using the free option within Dev/Test for the exercises in this course.

Some of the limitations of an App Service are:

* You have limited access to the host server, so you are unable to control the underlying OS or install software on the server.
* You’re always paying for the service plan, even if your services or application isn’t running.
* There are hardware limitations, such as a maximum of 14GB of memory and 4 vCPU cores per instance
* While they support multiple languages, as noted in the benefits above, they are limited to just using those languages (as of when this course was built).

### Use Cases
Each of these has their own use cases, although sometimes there is still some ambiguity on when to use each. Virtual Machines are usually better when you need control of the underlying operating system or are using custom software to support your needs; an app service is typically better for lightweight applications and services, especially when you don't have the need for high performance compute services. Additionally, you'll need to take into consideration the hardware limitations of App Services, as noted above.

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/37.jpg)

## Exercise: Virtual Machines vs. App Services

### Virtual Machines vs. App Services
For each of the three scenarios below, analyze and determine whether a virtual machine or an app service would be best served for the situation. It's important to note that this involves some level of ambiguity - you should feel free to expand beyond the given scenario and consider any other areas that might be important in making your decision.

### Scenario 1
Your company wants to deploy a series of lightweight APIs as part of their plan to shift to using microservices in the future. The company is very cost-conscious due to the current economic environment, and wants to focus on using the correct services right now, and is less concerned about scaling concerns due to stagnant growth.

### Scenario 1 Scratchpad
You can use this space as a scratchpad of your thoughts on Scenario 1. Note that this will lock after you submit it.

Your reflection
* App Services

### Scenario 2
Your company has recently signed a sizable government contract in which you will deploy various apps for the related government departments to use. The contract was a big win for the company, as it vastly increases the number of users of your apps. Additionally, the contract does contain provisions that require dedicated servers for security reasons to host any of the government department's services and information. Relatedly, some of the different departments' applications are required to be maintained on different servers.

### Scenario 2 Scratchpad
You can use this space as a scratchpad of your thoughts on Scenario 2. Note that this will lock after you submit it.

Your reflection
* Virtual Machines

### Scenario 3
You have been assigned to determine the cloud needs for a new product your company will soon be launching. In the past couple of years, your company has been on a roller coaster ride - some product launches meet massive success, while others flounder pretty quickly out of the gates. As such, the product manager is a bit wary of immediately creating a bunch of resources without knowing for sure what the real demand for this new product will be. The application currently utilizes ~5 GB on 2 CPUs during your stress testing, but is definitely a minimum viable product, and could grow vastly in size and compute resources if successful.

### Scenario 3 Scratchpad
You can use this space as a scratchpad of your thoughts on Scenario 3. Note that this will lock after you submit it.

### Your reflection
* App Services

## Solution: Virtual Machines vs. App Services

### Scenario 1
>>Your company wants to deploy a series of lightweight APIs as part of their plan to shift to using microservices in the future. The company is very cost-conscious due to the >>current economic environment, and wants to focus on using the correct services right now, and is less concerned about scaling concerns due to stagnant growth.

Some key points that stood out to me were:

* Deploying a series of lightweight APIs
* Less concern about scaling up processing power
* Cost-consciousness

I would choose an <strong>App Service</strong> in this situation. Lightweight APIs tend to be well-suited to App Services over VMs, and won't approach the size limit for App Services very easily. Additionally, App Services cost less than VMs do. Lastly, since the ability to scale quickly is less of a concern, we don't need to factor that into the analysis.

As the company shifts into microservices, Azure Functions would also be a good compute option for them to consider, but that won’t be covered until a later course.

### Scenario 2
>>Your company has recently signed a sizeable government contract in which you will deploy various apps for the related government departments to use. The contract was a big win >>for the company, as it vastly increases the number of users of your apps. Additionally, the contract does contain provisions that require dedicated servers for security >>reasons to host any of the government department's services and information. Relatedly, some of the different departments' applications are required to be maintained on >>different servers.

A couple of key points that stood out to me were:

* A vast increase in the number of users
* The need for dedicated servers for security reasons

This situation is likely best for <strong>Virtual Machines</strong>. Handling the vast increase in the number of users, with separate, dedicated servers, is going to be better achieved this way.

### Scenario 3
>>You have been assigned to determine the cloud needs for a new product your company will soon be launching. In the past couple of years, your company has been on a roller >>coaster ride - some product launches meet massive success, while others flounder pretty quickly out of the gates. As such, the product manager is a bit wary of immediately >>creating a bunch of resources without knowing for sure what the real demand for this new product will be. The application currently utilizes ~5 GB on 2 CPUs during your stress >>testing, but is definitely a minimum viable product, and could grow vastly in size and compute resources if successful.

This is a bit of a tough one - it's important to remember that in real-life situations, there may not always be a clear dividing line on exactly which service is best.

Some key points that stood out to me were:

* The confidence level of this application being a massive success seems low (do we want to assume we'll need a lot of scaling?)
* The application currently utilizes ~5 GB on 2 CPUs during stress testing
* The potential the app will grow in resource needs

The answer here depends greatly on which of the above points you highlight. In the current situation, an App Service likely works fine - it can scale vertically to meet different demand levels, and the compute resources needed are well within App Service limits. However, there's some consideration that Virtual Machines may be necessary in the near future if many more features are added, or demand changes in a way that requires vertical scaling. In fact, I'd argue that the problem so far is a bit ill-defined - I'd want to know what level of control we need over the underlying OS, security requirements we have, etc.

## Creating a Virtual Machine

Please open the link on a new tab to follow the tutorial:

[![IMAGE ALT TEXT](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/38.jpg)](https://www.youtube.com/watch?v=ngD-D9XBPw4&feature=emb_logo)

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/38.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/39.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/40.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/41.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/42.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/43.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/44.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/45.jpg)
![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/46.jpg)

The steps I took to create a Linux Virtual Machine on Azure were:

* 1. On the homepage, click "Create a resource"
* 2. Click on "Compute" in the left menu
* 3. Click on "Virtual Machine"
* 4. Create a Linux VM with the following details:

* Subscription: This will vary for you. Should default to your subscription.
* Resource Group: "hello-world-rg"
* VM Name: "linux-vm-west"
* Region: West US 2 or a region closest to you that's available
* Availability Options: Default option of "No infrastructure redundancy required" is fine here.
* Image: Ubuntu Server (any version) but I'm going to use the latest version 18.04 LTS
* Azure Spot instance: No
* Size: Click on "Select Size" and select "Standard B1ls"
* Authentication type: Password
* Username: (any username you choose) something other than the default "AzureUser" I used "udacityadmin"
* Password: (any password you choose) "Udacityadmin@123"
* Inbound Port Rules: "Allow Select Ports" and make sure from the drop-down menu, 22 and 80 are selected.

### Connect and deploy an App using the command line:

Please watch the video to follow the tutorial:

[![IMAGE ALT TEXT](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/47.jpg)](https://www.youtube.com/watch?time_continue=20&v=Ty_ZR_E6Ukg&feature=emb_logo)

To connect to the created VM, I did the following (note that Windows users should use PowerShell or Bash):

* 1. We'll need our admin username we set when creating the VM - "udacityadmin"
* 2. We'll need the public IP address of our VM. You can use the following command to grab the IPs addresses for a particular VM from the CLI—
```
az vm list-ip-addresses -g <RESOURCE-GROUP> -n <VIRTUAL-MACHINE-NAME>
```
or use Azure portal.
* 3. Next, we're going to copy a basic Flask app from my local machine to the VM. We'll be using the secure copy utility—
```
scp -r <SOURCE-DIR> [ADMIN-NAME]@[PUBLIC-IP]:<TARGET-DIR>
```
In this example, I used—
```
scp -r ./web udacityadmin@IPADDRESS:/home/udacityadmin
```
### NOTE: 
The first time you try connecting to the VM, you'll see a similar message to the one below and should answer 'yes' to permanently add the IP address to the list of known hosts.

>>The authenticity of host '52.191.135.139 (52.191.135.139)' can't be established.
>>ECDSA key fingerprint is SHA256:7bBVTsYNImhXxAn+xscCHm/OkcodHZS615VSKO3GP8c.
>>Are you sure you want to continue connecting (yes/no)?

* 4. Once the files have been copied to the VM, we can connect to the VM using—
```
ssh [ADMIN-NAME]@[PUBLIC-IP]
```

* 5. We can use "ls" to see the web directory we just uploaded

* 6. Python 3 is already installed on the VM. We'll install Python Virtual Environment and NGNIX to use as a reverse proxy
```
sudo apt-get -y update && sudo apt-get -y install nginx python3-venv
```

* 7. Before we run the app, we have to configure Nginx to redirect all incoming connections on port 80 to our app that is running on localhost port 3000

* By default, Nginx has a default page that is displayed. If you visit the public IP address in your browser, you should see this page rendered.
* We'll navigate to the <strong>/etc/nginx/sites-available</strong> directory—
```cd /etc/nginx/sites-available```

* We’ll first unlink the default site using 
```sudo unlink /etc/nginx/sites-enabled/default```

* Then we’ll create a new file <strong>reverse-proxy.conf</strong> in the <strong>/etc/nginx/sites-available</strong>—
<strong>sudo vim reverse-proxy.conf</strong>
* We're going to add the following code to this file:

```
server {
    listen 80;
    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection keep-alive;
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
 }
 
 ```
 
Now we’ll activate the directories by creating a sym link to the /sites-enabled directory 

```sudo ln -s /etc/nginx/sites-available/reverse-proxy.conf /etc/nginx/sites-enabled/reverse-proxy.conf```

* We have to restart nginx so the changes take effect. ```sudo service nginx restart```

* 8. cd to web

* 9. Create venv ```python3 -m venv venv```
* 10. Activate the env ```source venv/bin/activate```
* 11. Upgrade pip in our virtual environment and then Install dependencies ```pip install --upgrade pip pip install -r requirements.txt```
* 12. We'll run our app ```python application.py```
* 13. In a web browser, we can visit the public IP address of the VM and you should see the application
* 14. Type "exit" to disconnect from the VM

<strong>Note:</strong> Azure free account only allows 750 hours of free hosting. Make sure to delete this VM after creation for any exercises to avoid charges.

<strong>Cleanup</strong>
If we no longer need a resource, we can delete them through the portal.

* 1. From the homepage, click on "Resource Group"
* 2. Click on the resource group you want to manage
* 3. You have two options—"Delete resource group" or if you want to keep the resource group, you can click on the individual or collection of resources you want to delete and click on "Delete"

![](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/48.jpg)

### QUESTION 2 OF 2
You've gone through all the steps for creating a Virtual Machine and deploying an app to it, and everything appears to be working from within the VM itself. However, when you navigate to the public IP address, it gives a connection error. Which of the following is a likely cause of the issue?

* You need to make sure the VM is listening on port 80

## Exercise: Creating a Virtual Machine

### Create a Linux Virtual Machine
In this exercise, you'll create and connect to a Linux Virtual Machine in Azure.

<strong>Prerequisite:</strong> If you're using Windows, you’ll need PowerShell or Bash to connect to the VM with ssh. Windows 10 should already have Powershell installed. If you don't have it already installed, here is a guide on how to install it.

* 1. Create a Linux VM called “linux-vm-west” inside “resource-group-west” which was created in a previous exercise. The VM should have the following configurations:
>> * VM Name: "linux-vm-west"
>> * Region: West US or the closest region to you that's available
>> * Availability Options: No infrastructure redundancy required.
>> * Image: Ubuntu Server (any version)
>> * Azure Spot instance: No
>> * Size: Standard B1ls
>> * Authentication type: Password
>> * Username: (any username you choose)
>> * Password: (any password you choose)
>> * Inbound Port Rules: Allow both 22 and 80

* 2. After creating the VM, use <strong>secure copy</strong> to copy the ```web``` directory from [here](https://video.udacity-data.com/topher/2020/July/5f1875e2_create-vm-starter/create-vm-starter.zip) to the VM. ```scp -r ./web <USERNAME>@<IPADDRESS>:/home/<USERNAME>```
* 3. After copying the files to the VM, <strong>connect</strong> to it and run the command ```ls``` to check the ```web``` directory is on the VM.
* 4. Next, install ```python3-env``` and ```nginx``` ```sudo apt-get -y update && sudo apt-get -y install nginx python3-venv```
* 5. Next, configure nginx to listen for incoming traffic on port 80 and set port 3000 as the proxy.
>> * Navigate to ```/etc/nginx/sites-avaiable```
>> * Remove the ```default``` file
>> * Replace it with a file containing:

```server {
  listen 80;
  location / {
      proxy_pass http://localhost:3000;
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection keep-alive;
      proxy_set_header Host $host;
      proxy_cache_bypass $http_upgrade;
  }
}
```

* After saving the file, restart nginx ```sudo service nginx restart```
* 6. Change to the ```web``` directory and create and activate a virtual env
* 7. As a best practice, update pip in a newly created virtual env
* 8. Install dependencies from <strong>requirements.txt</strong>
* 9. Run the application and visit the public IP address in your browser. You should see the application running if done correctly.

### Cleanup
Once you're done with the exercise, be sure to delete the VM and it's resources to avoid incurring unwanted charges.

<strong>Note:</strong> Azure free accounts only allow 750 hours of free hosting. Make sure to delete this VM after completing the exercise to avoid charges.

## Solution: Creating a Virtual Machine

Please watch the video to follow the tutorial:

[![IMAGE ALT TEXT](https://raw.githubusercontent.com/ARBUCHELI/BERTELSMANN-SCHOLARSHIP---INTRODUCTION-TO-AZURE-APPLICATIONS-NANODEGREE-PROGRAM/main/Images/47.jpg)](https://www.youtube.com/watch?v=a5gKkVARnXU&feature=emb_logo)

In this solution video, I showed you an alternative way to create a Linux VM using Azure CLI. Use whichever method you feel more comfortable with moving forward. Connecting to the VM is done the same way in both instances.

* 1. First, we'll login using ```az login```
* 2. Next, we'll create our VM using ```az vm create```. If we don't pass a location, it defaults to the location of the resource group. This would be fine in most cases, but it's worth noting that sometimes a VM size might not be available in the same region as your resource group, so you'd have to pass in a location for a different region.

```
az vm create \
   --resource-group "resource-group-west" \
   --name "linux-vm-west" \
   --location "westus2" \
   --image "UbuntuLTS" \
   --size "Standard_B1ls" \
   --admin-username "udacityadmin" \
   --generate-ssh-keys \
   --verbose
```
   
* 3. Upon success, you will have a JSON response.
* 4. Next we will open port 80 to allow outside traffic to our VM

az vm open-port \
    --port "80" \
    --resource-group "resource-group-west" \
    --name "linux-vm-west"
    
* 5. Upon success, you will receive a JSON response.
* 
Alternatively, you can check the screenshot below for the same approach through the portal.

![](https://video.udacity-data.com/topher/2020/July/5f075463_linux-vm-solution/linux-vm-solution.png)

### Connecting to the VM
* 1. We'll need the admin username we set when creating the VM
* 2. We'll need the public IP address of our VM. You can use the following command to grab the IP address for a particular VM from the CLI.
```az vm list-ip-addresses -g resource-group-west -n linux-vm-west```
* 3. Next we're going to copy a basic Flask app from my local machine to the VM. We'll be using the [secure copy utility](http://www.hypexr.org/linux_scp_help.php) ```scp -r ./web udacityadmin@IPADDRESS:/home/udacityadmin```
* 4. Now we can connect to the VM with “ssh [username]@[IP Address]” <strong>Note:</strong> Since we generated SSH keys, you won't be prompted for a password.
* 5. Run ```ls``` to see the web directory we just uploaded
* 6. Python 3 is already installed on the VM. We'll install Python Virtual Environment and NGNIX to use as a reverse proxy
```sudo apt-get -y update && sudo apt-get -y install nginx python3-venv```
* 7. Before we run the app, we have to configure Nginx to redirect all incoming connections on port 80 to our app that is running on localhost port 3000

>> * By default, Nginx has a default page that is displayed. If you visit the public IP address in your browser, you should see this page rendered.
>> * We'll navigate to the <strong>/etc/nginx/sites-available</strong> directory—
```cd /etc/nginx/sites-available```
>> * We’ll first unlink the default site using ```sudo unlink /etc/nginx/sites-enabled/default```
>> * Then we’ll create a new file <strong>reverse-proxy.conf</strong> in <strong>/etc/nginx/sites-available—</strong>
```sudo vim reverse-proxy.conf```
>> * We're going to add the following code to this file:

```
server {
    listen 80;
    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection keep-alive;
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
 }
 ```
 
* 8. Now we’ll activate the directories by creating a sym link to the <strong>/sites-enabled</strong> directory 
```sudo ln -s /etc/nginx/sites-available/reverse-proxy.conf /etc/nginx/sites-enabled/reverse-proxy.conf```
>> * We have to restart nginx so the changes take effect
```sudo service nginx restart```

### Deploying the App to the VM
This section is the same as the earlier walkthrough, so we'll skip a solution video for it.

To deploy the app on the virtual machine, I did the following:

* 1. CD to ```web```
* 2. Create venv ```python3 -m venv venv```
* 3. Activate the env ```source venv/bin/activate```
* 4. Upgrade pip in our virtual environment and then Install dependencies—
```pip install --upgrade pip pip install -r requirements.txt```
* 5. We'll run our app ```python application.py```
* 6. In a web browser, we can visit the publicIpaddress
* 7. Type "exit" to disconnect from the VM

### Cleanup
If we no longer need a resource, we can delete them through the portal. The quickest way to do this from the CLI is to delete the resource group. This will delete all resources in that group

```az group delete -n resource-group-west```

_________________________________________________________________________________________________________________________________________________________________________________
# GLOSSARY 

### Reverse Proxy:
In computer networks such as the internet, a reverse proxy is a common type of proxy server that is accessible from the public network. Large websites and content delivery networks use reverse proxies –together with other techniques– to balance the load between internal servers. Reverse proxies can keep a cache of static content, which further reduces the load on these internal servers and the internal network. It is also common for reverse proxies to add features such as compression or TLS encryption to the communication channel between the client and the reverse proxy.

### Unit Testing:
In computer programming, unit testing is a software testing method by which individual units of source code—sets of one or more computer program modules together with associated control data, usage procedures, and operating procedures—are tested to determine whether they are fit for using.

### Integration Testing: 
Is the phase in software testing in which individual software modules are combined and tested as a group. Integration testing is conducted to evaluate the compliance of a system or component with specified functional requirements.  It occurs after unit testing and before validation testing.

### Content Management System: 
A content management system, often abbreviated as CMS, is software that helps users create, manage, and modify content on a website without the need for specialized technical knowledge.
In simpler language, a content management system is a tool that helps you build a website without needing to write all the code from scratch (or even know how to code at all).
Instead of building your own system for creating web pages, storing images, and other functions, the content management system handles all that basic infrastructure stuff for you so that you can focus on more forward-facing parts of your website.




# Adaptation as a repository: Andrés R. Bucheli.
